from datetime import datetime, date
from typing import Optional, List,Literal,Dict
from pydantic import BaseModel, ConfigDict, EmailStr,computed_field,field_validator
from enum import Enum

# User schemas
class UserBase(BaseModel):
    username: str
    email: EmailStr
    full_name: Optional[str] = None
    is_active: bool = True


class UserRole(str, Enum):
    admin = "admin"
    member = "member"

class TaskStatus(str, Enum):
        initialised= "initialised"
        in_progress = "in-progress"
        completed = "completed"



class UserCreate(UserBase):
    email: EmailStr
    name: str
    family_name: str
    family_id: int

class UserRequest(BaseModel):
    user_email: EmailStr

class FamilyRequest(BaseModel):
    family_id: int
    
class UserUpdate(BaseModel):
    username: Optional[str] = None
    email: Optional[EmailStr] = None
    full_name: Optional[str] = None
    is_active: Optional[bool] = None

class FamilyResponse(BaseModel):
    model_config = ConfigDict(from_attributes=True)
    id: int
    name: str


# class FamilyUsers(BaseModel):
#     model_config = ConfigDict(from_attributes=True)
#     id: int  # Added the missing id field
#     username: str
class FamilyUsers(BaseModel):
    model_config = ConfigDict(from_attributes=True)
    id: int
    name: str
    users: List[UserBase]


class FamilyMemberResponse(BaseModel):
    id: int
    name: str
    
class UserResponse(BaseModel):
    model_config = ConfigDict(from_attributes=True)
    id: str 
    name: str
    email: EmailStr
    family_id: str
    role: UserRole

class GetMeResponse(UserBase):
    model_config = ConfigDict(from_attributes=True)
    
    id: int
    created_at: datetime
    updated_at: datetime
    family: FamilyResponse

    # @computed_field
    # @property
    # def family_members(self) -> List[FamilyMemberResponse]:
    #     """Extract the names and IDs of family members."""
    #     # Check if we have family data from SQLAlchemy
    #     if hasattr(self, 'family') and self.family and hasattr(self.family, 'users'):
    #         return [
    #             {"id": member.id, "name": member.name} 
    #             for member in self.family.users 
    #             if member.name and member.id != self.id  # Exclude self and ensure name exists
    #         ]
    #     return []



class ChecklistItem(BaseModel):
    id: int  # this is autogenerated by the DB, so in input models it might be optional
    title: str
    completed: bool



# Task schemas
class TaskBase(BaseModel):
    title: str
    creator_id: int
    assignee_id: int
    family_id: int
    due_date: datetime
    status: TaskStatus
    checklist: Optional[List[ChecklistItem]]= None

# class TaskCreate(TaskBase):
#     pass


class UserStatusRequest(BaseModel):
    user_id: int
    status:  bool
        



class TaskCreate(BaseModel):
    title: str 
    creator_id: str
    assignee_id: str
    family_id: str
    due_date: datetime
    description: Optional[str]=None
    checklist: Optional[List[ChecklistItem]]= None
class DeleteTask(TaskBase):
    task_id: str
class GetTasks(BaseModel):
    family_id: int
    date: date
class TaskUpdate(BaseModel):
    title: Optional[str] = None
    content: Optional[str] = None
    published: Optional[bool] = None

class TaskResponse(TaskBase):
    model_config = ConfigDict(from_attributes=True)
    
    public_id: str
    creator_id: str  
    assignee_id: str
    family_id: str
    due_date: datetime
    checklist: Optional[List[ChecklistItem]] = None

    @field_validator('checklist', mode='before')
    @classmethod
    def transform_checklist(cls, v):
        """Transform checklist from old dict format to new list format"""
        if v is None:
            return None
        
        # Handle old format: {'items': [...]}
        if isinstance(v, dict) and 'items' in v:
            return v['items']
        
        # Handle new format: [...]
        if isinstance(v, list):
            return v
            
        # Handle unexpected format
        raise ValueError(f"Invalid checklist format: {type(v)}")
    # assignee_name: str



class LoginRequest(BaseModel):
    email: EmailStr
    password: str

class SignupRequest(BaseModel):
    email: EmailStr
    password: str
    name: str
    family_name: str

class EmailVerificationRequest(BaseModel):
    user_id: str
    

class ChecklistItem(BaseModel):
    id: int
    title: str
    completed: bool = False

    
class TaskRequest(BaseModel):
    id: str


class CreateMemberRequest(BaseModel):
    name: str
    email: EmailStr
    family_id: int
    family_name: str